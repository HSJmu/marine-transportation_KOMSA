---
title: "newgrid_chisq"
author: "HSJ"
date: '2022-07-30'
output: html_document
editor_options: 
  chunk_output_type: console
---


- 작업경로설정 및 데이터 불러오기
```{r setup, include=FALSE}
library(tidyverse)
library(tmap)
library(sf)
library(cowplot)
tmap_mode("view")

setwd("C:/Users/user/Desktop/해양데이터/해양격자대입함수")

new_Grid <- read_sf("grid_final/grid_final.shp")
ocean_data <- read.csv("C:/Users/user/Desktop/해양데이터/중해심 통합본_2022.csv")

new_Grid
Sys.getlocale() #인코딩정보 확인
Sys.setlocale("LC_ALL", "C")
ocean_data <- read.csv("C:/Users/user/Desktop/해양데이터/중해심 통합본_2022.csv",encoding = "UTF-8")
Sys.setlocale("LC_ALL", "korean") 

colnames(ocean_data)

# 컬럼명에 .이 있을 경우 입력에 불편함 있을 수 있기 때문에 _로 변경해줌
colnames(ocean_data) <- gsub("[.]","_",colnames(ocean_data))



# 그리드번호 열 생성
df <- {}

for (i in 1:nrow(new_Grid)){
  if (new_Grid$level[i] == 'lv2'){
    data <- new_Grid$OG_ID_lv2[i]
  } else if (new_Grid$level[i] == 'lv3'){
    data <- new_Grid$OG_ID_lv3[i]
  } else if (new_Grid$level[i] == 'lv4'){
    data <- new_Grid$OG_ID_lv4[i]
  }
  df <- rbind(df, data)
}
new_Grid$OG_ID <- df
new_grid <- new_Grid[,c(4,5,6)]
new_grid$OG_ID <- new_grid$OG_ID %>% as.character()
new_grid$OG_ID %>% class()
```

## 사고데이터와 join
```{r}
# 문자 -> 실수형으로 변환
ocean_data$위도_계산_ <- ocean_data$위도_계산_ %>% as.numeric()
ocean_data$경도_계산_ <- ocean_data$경도_계산_ %>% as.numeric()


# 위치값 없는 행 제거
ocean_data <- ocean_data[!is.na(ocean_data$위도_계산_) == TRUE, ]

# sf데이터로 바꾸기 및 crs 지정
ocean_data <-
  st_as_sf(ocean_data, coords = c("경도_계산_", "위도_계산_")) %>% st_set_crs(4326) 



ocean_data <- st_transform(ocean_data, 27700)
new_grid <- st_transform(new_grid, 27700)

# st_intersection을 사용해서 사고데이터에 각 사고의 격자데이터 id 넣기
ocean_data_intersect <- st_intersection(ocean_data, new_grid)
a <- unique(ocean_data_intersect$OG_ID) # 사고데이터가 있는 격자의 갯수가 6512개(기존 grid(new_grid)격자 : 10605개)

# 사고난 격자만 남김
grid_yesocean <- st_join(new_grid, ocean_data_intersect)
grid_yesocean <-
  grid_yesocean[!is.na(grid_yesocean$일련번호), ][c(1, 2, 3)] %>% unique()


# crs 변환
new_grid <- st_transform(new_grid, 4326)
ocean_data_intersect <- st_transform(ocean_data_intersect, 4326)
ocean_data <- st_transform(ocean_data, 4326)

ocean_data_intersect %>% st_crs()
ocean_data_intersect$geometry


#시각화
# tm_shape(grid_yesocean) +
#   tm_polygons(alpha = 0) +
#   tm_basemap("OpenStreetMap") +
#   tm_shape(ocean_data_intersect) +
#   tm_symbols(size = .01)
```

# 데이터 split
```{r}
ocean_data_intersect$해양사고종류_분석용_ %>% unique()

# 해양사고유무를 나타내주는 열 추가
ocean_data_intersect$해양사고유무 <- ifelse(ocean_data_intersect$해양사고종류_분석용_ %in% c("충돌", "접촉", "좌초", "전복", "침몰"),"O","X")
# 1. 어선
fishingBoat <- ocean_data_intersect %>% filter(선박용도_대_ == "어선")

# 2. 비어선
N_fishingBoat <- ocean_data_intersect %>% filter(선박용도_대_ == "비어선")

# 3. 해양교통사고
ocenaAccident <-
  ocean_data_intersect %>% filter(해양사고종류_분석용_ %in% c("충돌", "접촉", "좌초", "전복", "침몰"))

# 4. 해양교통사고 이외
N_ocenaAccident <-
  ocean_data_intersect %>% filter(!해양사고종류_분석용_ %in% c("충돌", "접촉", "좌초", "전복", "침몰"))
```

# 영가설 설정
# H0 : 특정변수(계절, 시간대 등)가 주는 영향이 격자별로 다르지 않다.
# H1 : 특정변수(계절, 시간대 등)가 주는 영향이 격자별로 다르다.

# 어선 비어선으로 나눈 데이터용 함수
```{r}
fishingBoat_DropGeo <- fishingBoat %>% st_drop_geometry() 
N_fishingBoat_DropGeo <- N_fishingBoat %>% st_drop_geometry() 

fishingBoat_DropGeo$해양사고발생시간대 %>% length()
fishingBoat_DropGeo$OG_ID %>% length()
fishingBoat_DropGeo$OG_ID <- as.character(fishingBoat_DropGeo$OG_ID)

## 선박용도별로 나눈 데이터용 함수 (어선(변수명 : fishingBoat_intersect_DropGeo), 비어선)
chisq_ShipType <- function(data,gridName) {
  # 1. 카이제곱대입 - 해양사고발생시간대, 계절, 해양사고종류_분석용_ ##################################################################################################################
  time <-
    chisq.test(data$해양사고발생시간대,
               data$OG_ID)
  wheater <-
    chisq.test(data$계절,
               data$OG_ID)
  crush <-
    chisq.test(data$해양사고종류_분석용_,
               data$OG_ID)
  
  # 2. 텍스트 및 시각화 출력 - 카이제곱 결과에 따라 대입한 그리드에서 많이 일어나는 종류의 사고 파악 ###################################################################################
  
  cat("그리드 번호 입력(''사이에 입력(필수)) : ",gridName , "\n") # 그리드이름 출력
  cat("\n")
  
  
  ## 2-1. 시간대(time) ------------------------------------------------------------------------------------------------------------------------------------------------------------------
   if (time$p.value < 0.05) {
     
     ### 2-1-1. 시간대에 대한 텍스트 출력
     cat("시간대 : ",names(which.max(time$stdres[, gridName])),"\n") # 잔차가 가장 큰 시간대 출력(클수록 사고가 많이 일어나는 시간대임)
     ### 실제값과 예측값의 차이
     cat(
       "        ",
       names(which.max(time$stdres[, gridName])),
       "에 예측보다",
       round(time$observed[, gridName][which.max(time$stdres[, gridName])] / time$expected[, gridName][which.max(time$stdres[, gridName])], 1),
       "배 더 많은 사고가 일어난다. \n"
       )
     ### 해당그리드에서 일어난 사고 중 잔차가 가장 큰 시간대에서 일어난 사고비중 및 건수 - 그리드의 사고 건수 자체가 적을 경우 결과의 정확도가 낮을 수 있기 때문에 그것을 파악하고자 표현함.
     cat(
       "        ",
       gridName,
       "에서 일어나는 사고건수의 총합 중",
       names(which.max(time$stdres[, gridName])),
       "에 일어나는 사고는",
       time$observed[, gridName][which.max(time$stdres[, gridName])],
       "건이며, ",
       round(time$observed[, gridName][which.max(time$stdres[, gridName])] / sum(time$observed[, gridName]) * 100, 2),
       "%를 차지한다.\n")
     
     
     ### 2-1-2. 시간대에 대한 시각화 출력
     #### 시각화를 위한 작업
     # time 확인
     ## 실제값
     real_T <- time$observed[,gridName]
     real_T <- as.data.frame(real_T)
     real_T$'time' <- rownames(real_T)
     rownames(real_T) <- c(1:nrow(real_T))
     ## 예측값
     expe_T <- round(time$expected[,gridName],1)
     expe_T <- as.data.frame(expe_T)
     expe_T$'time' <- rownames(expe_T)
     rownames(expe_T) <- c(1:nrow(expe_T))
     
     ## 실제 & 예측 join, 
     last_T <- left_join(real_T,expe_T, by="time")
     last_T <- last_T[c(2,1,3)]
     colnames(last_T) <- c("time","실제사고수","예측사고수")
     last_T$'실제/예측' <- ifelse(round((last_T$실제사고수) /(last_T$예측사고수),1)%in% c(Inf,NA,NaN),0,round((last_T$실제사고수) /(last_T$예측사고수),1)) 
     last_T <- pivot_longer(last_T, cols =c(`실제사고수`,`예측사고수`) )
     
     #### 시각화
     # 1) 막대
     p1_T <- ggplot(last_T,aes(x=time,y=value,fill=name))+
       geom_bar(stat='identity',position='dodge')+
       geom_text(aes(label=paste0(value,"건")) ,vjust = 1.5,
                 position=position_dodge(width=1))+
       scale_x_discrete(limits=c("0-4시","4-8시","8-12시","12-16시","16-20시","20-24시"))+
       scale_fill_manual(values = c("#4292C6","#9ECAE1"))+
       theme_light()+
       theme(panel.border = element_blank(),
             panel.grid.minor.x = element_blank(), # 그래프 보조선 제거(x축)
             axis.title.x = element_blank(), # x축 제목 제거
             legend.position = "bottom",     # 범례 위치 지정
             legend.title = element_blank())+ # 범례 제목 제거
       labs(y="사고건수")
     # 2) 라인
     p2_T <- ggplot(last_T, aes(x = time, y = `실제/예측`,group=1)) + geom_line(color = "red") +
       geom_point(color = "red") + geom_text(aes(label = paste0(`실제/예측`, "배"), vjust =-.3)) +
       scale_x_discrete(limits=c("0-4시","4-8시","8-12시","12-16시","16-20시","20-24시"))+
       ggtitle("시간대별 사고건수(실제,예측) 및 실제값 / 예측값 ")+
       theme_light()+
       theme(panel.border = element_blank(),
             panel.grid.minor.x = element_blank(),
             axis.text.x = element_blank(),
             axis.title.x = element_blank(),
             plot.title = element_text(size=20,color="blue")) +
       scale_y_continuous(limits = c(0,max(last_T$`실제/예측`)+0.2),
                          breaks = seq(1,round(max(last_T$`실제/예측`),1),2))
     
     # 1) 막대 + 2) 라인
     print(plot_grid(p2_T,p1_T,ncol=1,rel_heights = c(.35,.8)))
   }
  
  else {
    print("시간대는 격자별 사고건수와 연관이 없다.")
  }

  cat("\n")
 cat("------------------------------------------------------------\n")
  
  ## 2-2. 계절(wheater) ----------------------------------------------------------------------------------------------------------------------------------------------------------
 
 if (wheater$p.value < 0.05) {
   
   ### 2-2-1. 계절에 대한 텍스트 출력
   cat("계절 : ",names(which.max(wheater$stdres[, gridName])),"\n") # 잔차가 가장 큰 시간대 출력(클수록 사고가 많이 일어나는 계절임)
   
   ### 실제값과 예측값의 차이
   cat(
     "       ",
     names(which.max(wheater$stdres[, gridName])),
     "에 예측보다",
     round(wheater$observed[, gridName][which.max(wheater$stdres[, gridName])] / wheater$expected[, gridName][which.max(wheater$stdres[, gridName])], 1),
     "배 더 많은 사고가 일어난다. \n"
     )
   ### 해당그리드에서 일어난 사고 중 잔차가 가장 큰 시간대에서 일어난 사고비중 및 건수 - 그리드의 사고 건수 자체가 적을 경우 결과의 정확도가 낮을 수 있기 때문에 그것을 파악하고자 표현함.
   cat(
     "       ",
     gridName,
     "에서 일어나는 사고건수의 총합 중",
     names(which.max(wheater$stdres[, gridName])),
     "에 일어나는 사고는",
     wheater$observed[, gridName][which.max(wheater$stdres[, gridName])],
     "건이며, ",
     round(wheater$observed[, gridName][which.max(wheater$stdres[, gridName])] / sum(wheater$observed[, gridName]) *100, 2),
     "%를 차지한다.\n"
   )
   
   ### 2-2-2. 계절에 대한 시각화
   #### 시각화를 위한 작업
   # wheater 확인
   ## 실제값
   real_W <- wheater$observed[,gridName]
   real_W <- as.data.frame(real_W)
   real_W$'wheater' <- rownames(real_W)
   rownames(real_W) <- c(1:nrow(real_W))
   
   ## 예측값
   expe_W <- round(wheater$expected[,gridName],1)
   expe_W <- as.data.frame(expe_W)
   expe_W$'wheater' <- rownames(expe_W)
   rownames(expe_W) <- c(1:nrow(expe_W))
   
   # 실제 & 예측 join, 
   last_W <- left_join(real_W,expe_W, by="wheater")
   last_W <- last_W[c(2,1,3)]
   colnames(last_W) <- c("wheater","실제사고수","예측사고수")
   last_W$'실제/예측' <- ifelse(round((last_W$실제사고수) /(last_W$예측사고수),1)%in% c(Inf,NA,NaN),0,round((last_W$실제사고수) /(last_W$예측사고수),1)) 
   last_W <- pivot_longer(last_W, cols =c(`실제사고수`,`예측사고수`) )
   
   # 시각화 
   # 1) 막대
   p1_W <- ggplot(last_W,aes(x=wheater,y=value,fill=name))+
     geom_bar(stat='identity',position='dodge')+
     geom_text(aes(label=paste0(value,"건")) ,vjust = 1.5,
               position=position_dodge(width=1))+
     scale_x_discrete(limits=c("봄","여름","가을","겨울"))+
     scale_fill_manual(values = c("#4292C6","#9ECAE1"))+
     theme_light()+
     theme(panel.border = element_blank(),
           panel.grid.minor.x = element_blank(), # 그래프 보조선 제거(x축)
           axis.title.x = element_blank(), # x축 제목 제거
           legend.position = "bottom",     # 범례 위치 지정
           legend.title = element_blank())+ # 범례 제목 제목
     labs(y="사고건수")
   
   # 2) 선
   p2_W <- ggplot(last_W, aes(x = wheater, y = `실제/예측`,group=1)) + geom_line(color = "red") +
     geom_point(color = "red") + geom_text(aes(label = paste0(`실제/예측`, "배"), vjust =
                                              -.3)) +
     scale_x_discrete(limits=c("봄","여름","가을","겨울"))+
     ggtitle("계절별 사고건수(실제,예측) 및 실제값 / 예측값 ")+
     theme_light()+
     theme(panel.border = element_blank(),
           panel.grid.minor.x = element_blank(),
           axis.text.x = element_blank(),
           axis.title.x = element_blank(),
           plot.title = element_text(size=20,color="blue")) +
     scale_y_continuous(limits = c(0,max(last_W$`실제/예측`)+0.2)
                        ,breaks = seq(1,round(max(last_W$`실제/예측`),1),2))
   # 1) 막대 + 2) 라인
   print(plot_grid(p2_W,p1_W,ncol=1,
                   rel_heights = c(.35,.8)))
   }
  
  else {
    print("계절은 격자별 사고건수와 연관이 없다.")
  }
 
  cat("\n")
  cat("------------------------------------------------------------\n")
  
  
  ## 2-3. 해양사고종류(crush) -------------------------------------------------------------------------------------------------------------------------------------------
 
 if (crush$p.value < 0.05) {
   
   ### 2-3-1. 사고종류에 대한 텍스트 출력
   
   cat("해양사고종류 : ",names(which.max(crush$stdres[, gridName])),ifelse(names(which.max(crush$stdres[, gridName])) %in% c("충돌", "접촉", "좌초", "전복","침몰"),"(해양교통사고 O)","(해양교통사고 X)"),"\n") # 잔차가 가장 큰 시간대 출력(클수록 사고가 많이 일어나는 계절임) 
   ### 실제값과 예측값의 차이
   cat(
     "             ",
     names(which.max(crush$stdres[, gridName])),
     "에 예측보다",
     round(crush$observed[, gridName][which.max(crush$stdres[, gridName])] / crush$expected[, gridName][which.max(crush$stdres[, gridName])], 1),
     "배 더 많은 사고가 일어난다. \n"
     )
   ### 해당그리드에서 일어난 사고 중 잔차가 가장 큰 시간대에서 일어난 사고비중 및 건수 - 그리드의 사고 건수 자체가 적을 경우 결과의 정확도가 낮을 수 있기 때문에 그것을 파악하고자 표현함.
   cat(
     "             ",
     gridName,
     "에서 일어나는 사고건수의 총합 중",
     names(which.max(crush$stdres[, gridName])),
     "에 일어나는 사고는",
     crush$observed[, gridName][which.max(crush$stdres[, gridName])],
     "건이며, ",
     round(crush$observed[, gridName][which.max(crush$stdres[, gridName])] / sum(crush$observed[, gridName]) *100, 2),
     "%를 차지한다.\n"
     )
   
   ### 2-2-3. 사고종류에 대한 시각화
   #### 시각화를 위한 작업
   # crush 확인
   ## 실제값
   real_C <- crush$observed[,gridName]
   real_C <- as.data.frame(real_C)
   real_C$'crush' <- rownames(real_C)
   rownames(real_C) <- c(1:nrow(real_C))
   
   ## 예측값
   expe_C <- round(crush$expected[,gridName],1)
   expe_C <- as.data.frame(expe_C)
   expe_C$'crush' <- rownames(expe_C)
   rownames(expe_C) <- c(1:nrow(expe_C))
   
   ## 실제 & 예측 join, 
   last_C <- left_join(real_C,expe_C, by="crush")
   last_C <- last_C[c(2,1,3)]
   colnames(last_C) <- c("crush","실제사고수","예측사고수")
   last_C$'실제/예측' <- ifelse(round((last_C$실제사고수) /(last_C$예측사고수),1) %in% c(Inf,NA,NaN),0,round((last_C$실제사고수) /(last_C$예측사고수),1)) 
   last_C <- pivot_longer(last_C, cols =c(`실제사고수`,`예측사고수`) )
   # 시각화 
   # 1) 막대
   p1_C <- ggplot(last_C,aes(x=crush,y=value,fill=name))+
     geom_bar(stat='identity',position='dodge')+
     geom_text(aes(label=paste0(value,"건")) ,vjust = 1.5,
               position=position_dodge(width=1))+
     scale_fill_manual(values = c("#4292C6","#9ECAE1"))+
     theme_light()+
     theme(panel.border = element_blank(),
           panel.grid.minor.x = element_blank(), # 그래프 보조선 제거(x축)
           axis.title.x = element_blank(), # x축 제목 제거
           legend.position = "bottom",
           legend.title = element_blank())+     # 범례 위치 지정
           labs(y="사고건수")
   # 2) 선
   p2_C <- ggplot(last_C, aes(x = crush, y = `실제/예측`,group=1)) + geom_line(color = "red") +
     geom_point(color = "red") + geom_text(aes(label = paste0(`실제/예측`, "배"), vjust =
                                              -.3)) +
     #scale_x_discrete(limits=c("봄","여름","가을","겨울"))+
     ggtitle("사고종류별 사고건수(실제,예측) 및 실제값 / 예측값 ")+
     theme_light()+
     theme(panel.border = element_blank(),
           panel.grid.minor.x = element_blank(),
           axis.text.x = element_blank(),
           axis.title.x = element_blank(),
           plot.title = element_text(size=20,color="blue")) +
     scale_y_continuous(limits = c(0,max(last_C$`실제/예측`)+0.2),breaks = seq(1,round(max(last_C$`실제/예측`),1),2))
   # 1) 막대 + 2) 라인
   print(plot_grid(p2_C,p1_C,ncol=1,
                rel_heights = c(.35,.8)))
 
   }
  
  else {
    print("사고종류는 격자별 사고건수와 연관이 없다.")
  }

}
## TEST ##############################################################
# 어선데이터 test
fishingBoat_DropGeo$OG_ID %>% unique()
chisq_ShipType(fishingBoat_DropGeo,"GR4_G3E43_I4")

# 비어선데이터 test
N_fishingBoat_DropGeo$OG_ID %>% unique()
chisq_ShipType(N_fishingBoat_DropGeo,"GR3_F4L12_Y")


```


# 해양사고 유무로 나눈 데이터용 함수
```{r}
ocenaAccident_DropGeo <- ocenaAccident %>% st_drop_geometry() 
N_ocenaAccident_DropGeo <- N_ocenaAccident %>% st_drop_geometry() 


## 해양사고종류별로 나눈 데이터용 함수 (ocenaAccident_intersect_DropGeo,N_ocenaAccident_intersect_DropGeo)
chisq_crushType <- function(data,gridName) {
  # 1. 카이제곱대입 - 해양사고발생시간대, 계절, 해양사고종류_분석용_ ##################################################################################################################
  time <-
    chisq.test(data$해양사고발생시간대,
               data$OG_ID)
  wheater <-
    chisq.test(data$계절,
               data$OG_ID)
  shipType <-
    chisq.test(data$선박용도_대_ ,
               data$OG_ID)
  
  # 2. 텍스트 및 시각화 출력 - 카이제곱 결과에 따라 대입한 그리드에서 많이 일어나는 종류의 사고 파악 ###################################################################################
  
  cat("그리드 번호 입력(''사이에 입력(필수)) : ",gridName , "\n") # 그리드이름 출력
  cat("\n")
  
  
  ## 2-1. 시간대(time) ------------------------------------------------------------------------------------------------------------------------------------------------------------------
   if (time$p.value < 0.05) {
     
     ### 2-1-1. 시간대에 대한 텍스트 출력
     cat("시간대 : ",names(which.max(time$stdres[, gridName])),"\n") # 잔차가 가장 큰 시간대 출력(클수록 사고가 많이 일어나는 시간대임)
     ### 실제값과 예측값의 차이
     cat(
       "        ",
       names(which.max(time$stdres[, gridName])),
       "에 예측보다",
       round(time$observed[, gridName][which.max(time$stdres[, gridName])] / time$expected[, gridName][which.max(time$stdres[, gridName])], 1),
       "배 더 많은 사고가 일어난다. \n"
       )
     ### 해당그리드에서 일어난 사고 중 잔차가 가장 큰 시간대에서 일어난 사고비중 및 건수 - 그리드의 사고 건수 자체가 적을 경우 결과의 정확도가 낮을 수 있기 때문에 그것을 파악하고자 표현함.
     cat(
       "        ",
       gridName,
       "에서 일어나는 사고건수의 총합 중",
       names(which.max(time$stdres[, gridName])),
       "에 일어나는 사고는",
       time$observed[, gridName][which.max(time$stdres[, gridName])],
       "건이며, ",
       round(time$observed[, gridName][which.max(time$stdres[, gridName])] / sum(time$observed[, gridName]) * 100, 2),
       "%를 차지한다.\n")
     
     
     ### 2-1-2. 시간대에 대한 시각화 출력
     #### 시각화를 위한 작업
     # time 확인
     ## 실제값
     real_T <- time$observed[,gridName]
     real_T <- as.data.frame(real_T)
     real_T$'time' <- rownames(real_T)
     rownames(real_T) <- c(1:nrow(real_T))
     ## 예측값
     expe_T <- round(time$expected[,gridName],1)
     expe_T <- as.data.frame(expe_T)
     expe_T$'time' <- rownames(expe_T)
     rownames(expe_T) <- c(1:nrow(expe_T))
     
     ## 실제 & 예측 join, 
     last_T <- left_join(real_T,expe_T, by="time")
     last_T <- last_T[c(2,1,3)]
     colnames(last_T) <- c("time","실제사고수","예측사고수")
     last_T$'실제/예측' <- ifelse(round((last_T$실제사고수) /(last_T$예측사고수),1)%in% c(Inf,NA,NaN),0,round((last_T$실제사고수) /(last_T$예측사고수),1)) 
     last_T <- pivot_longer(last_T, cols =c(`실제사고수`,`예측사고수`) )
     
     #### 시각화
     # 1) 막대
     p1_T <- ggplot(last_T,aes(x=time,y=value,fill=name))+
       geom_bar(stat='identity',position='dodge')+
       geom_text(aes(label=paste0(value,"건")) ,vjust = 1.5,
                 position=position_dodge(width=1))+
       scale_x_discrete(limits=c("0-4시","4-8시","8-12시","12-16시","16-20시","20-24시"))+
       scale_fill_manual(values = c("#4292C6","#9ECAE1"))+
       theme_light()+
       theme(panel.border = element_blank(),
             panel.grid.minor.x = element_blank(), # 그래프 보조선 제거(x축)
             axis.title.x = element_blank(), # x축 제목 제거
             legend.position = "bottom",     # 범례 위치 지정
             legend.title = element_blank())+ # 범례 제목 제거
       labs(y="사고건수")
     # 2) 라인
     p2_T <- ggplot(last_T, aes(x = time, y = `실제/예측`,group=1)) + geom_line(color = "red") +
       geom_point(color = "red") + geom_text(aes(label = paste0(`실제/예측`, "배"), vjust =-.3)) +
       scale_x_discrete(limits=c("0-4시","4-8시","8-12시","12-16시","16-20시","20-24시"))+
       ggtitle("시간대별 사고건수(실제,예측) 및 실제값 / 예측값 ")+
       theme_light()+
       theme(panel.border = element_blank(),
             panel.grid.minor.x = element_blank(),
             axis.text.x = element_blank(),
             axis.title.x = element_blank(),
             plot.title = element_text(size=20,color="blue")) +
       scale_y_continuous(limits = c(0,max(last_T$`실제/예측`)+0.2),
                          breaks = seq(1,round(max(last_T$`실제/예측`),1),2))
     
     # 1) 막대 + 2) 라인
     print(plot_grid(p2_T,p1_T,ncol=1,rel_heights = c(.35,.8)))
   }
  
  else {
    print("시간대는 격자별 사고건수와 연관이 없다.")
  }

  cat("\n")
 cat("------------------------------------------------------------\n")
  
  ## 2-2. 계절(wheater) ----------------------------------------------------------------------------------------------------------------------------------------------------------
 
 if (wheater$p.value < 0.05) {
   
   ### 2-2-1. 계절에 대한 텍스트 출력
   cat("계절 : ",names(which.max(wheater$stdres[, gridName])),"\n") # 잔차가 가장 큰 시간대 출력(클수록 사고가 많이 일어나는 계절임)
   
   ### 실제값과 예측값의 차이
   cat(
     "      ",
     names(which.max(wheater$stdres[, gridName])),
     "에 예측보다",
     round(wheater$observed[, gridName][which.max(wheater$stdres[, gridName])] / wheater$expected[, gridName][which.max(wheater$stdres[, gridName])], 1),
     "배 더 많은 사고가 일어난다. \n"
     )
   ### 해당그리드에서 일어난 사고 중 잔차가 가장 큰 시간대에서 일어난 사고비중 및 건수 - 그리드의 사고 건수 자체가 적을 경우 결과의 정확도가 낮을 수 있기 때문에 그것을 파악하고자 표현함.
   cat(
     "      ",
     gridName,
     "에서 일어나는 사고건수의 총합 중",
     names(which.max(wheater$stdres[, gridName])),
     "에 일어나는 사고는",
     wheater$observed[, gridName][which.max(wheater$stdres[, gridName])],
     "건이며, ",
     round(wheater$observed[, gridName][which.max(wheater$stdres[, gridName])] / sum(wheater$observed[, gridName]) *100, 2),
     "%를 차지한다.\n"
   )
   
   ### 2-2-2. 계절에 대한 시각화
   #### 시각화를 위한 작업
   # wheater 확인
   ## 실제값
   real_W <- wheater$observed[,gridName]
   real_W <- as.data.frame(real_W)
   real_W$'wheater' <- rownames(real_W)
   rownames(real_W) <- c(1:nrow(real_W))
   
   ## 예측값
   expe_W <- round(wheater$expected[,gridName],1)
   expe_W <- as.data.frame(expe_W)
   expe_W$'wheater' <- rownames(expe_W)
   rownames(expe_W) <- c(1:nrow(expe_W))
   
   # 실제 & 예측 join, 
   last_W <- left_join(real_W,expe_W, by="wheater")
   last_W <- last_W[c(2,1,3)]
   colnames(last_W) <- c("wheater","실제사고수","예측사고수")
   last_W$'실제/예측' <- ifelse(round((last_W$실제사고수) /(last_W$예측사고수),1)%in% c(Inf,NA,NaN),0,round((last_W$실제사고수) /(last_W$예측사고수),1)) 
   last_W <- pivot_longer(last_W, cols =c(`실제사고수`,`예측사고수`) )
   
   # 시각화 
   # 1) 막대
   p1_W <- ggplot(last_W,aes(x=wheater,y=value,fill=name))+
     geom_bar(stat='identity',position='dodge')+
     geom_text(aes(label=paste0(value,"건")) ,vjust = 1.5,
               position=position_dodge(width=1))+
     scale_x_discrete(limits=c("봄","여름","가을","겨울"))+
     scale_fill_manual(values = c("#4292C6","#9ECAE1"))+
     theme_light()+
     theme(panel.border = element_blank(),
           panel.grid.minor.x = element_blank(), # 그래프 보조선 제거(x축)
           axis.title.x = element_blank(), # x축 제목 제거
           legend.position = "bottom",     # 범례 위치 지정
           legend.title = element_blank())+ # 범례 제목 제목
     labs(y="사고건수")
   
   # 2) 선
   p2_W <- ggplot(last_W, aes(x = wheater, y = `실제/예측`,group=1)) + geom_line(color = "red") +
     geom_point(color = "red") + geom_text(aes(label = paste0(`실제/예측`, "배"), vjust =
                                              -.3)) +
     scale_x_discrete(limits=c("봄","여름","가을","겨울"))+
     ggtitle("계절별 사고건수(실제,예측) 및 실제값 / 예측값 ")+
     theme_light()+
     theme(panel.border = element_blank(),
           panel.grid.minor.x = element_blank(),
           axis.text.x = element_blank(),
           axis.title.x = element_blank(),
           plot.title = element_text(size=20,color="blue")) +
     scale_y_continuous(limits = c(0,max(last_W$`실제/예측`)+0.2)
                        ,breaks = seq(1,round(max(last_W$`실제/예측`),1),2))
   # 1) 막대 + 2) 라인
   print(plot_grid(p2_W,p1_W,ncol=1,
                   rel_heights = c(.35,.8)))
   }
  
  else {
    print("계절은 격자별 사고건수와 연관이 없다.")
  }
 
  cat("\n")
  cat("------------------------------------------------------------\n")
  
  
  ## 2-3. 어선종류(shipType) -------------------------------------------------------------------------------------------------------------------------------------------
 
 if (shipType$p.value < 0.05) {
   
   ### 2-3-1. 어선종류에 대한 텍스트 출력
   
   cat("어선종류 : ",names(which.max(shipType$stdres[, gridName])),"\n") # 잔차가 가장 큰 어선종류 출력(클수록 사고가 많이 일어나는 계절임) 
   ### 실제값과 예측값의 차이
   cat(
     "          ",
     names(which.max(shipType$stdres[, gridName])),
     "에 예측보다",
     round(shipType$observed[, gridName][which.max(shipType$stdres[, gridName])] / shipType$expected[, gridName][which.max(shipType$stdres[, gridName])], 1),
     "배 더 많은 사고가 일어난다. \n"
     )
   ### 해당그리드에서 일어난 사고 중 잔차가 가장 큰 시간대에서 일어난 사고비중 및 건수 - 그리드의 사고 건수 자체가 적을 경우 결과의 정확도가 낮을 수 있기 때문에 그것을 파악하고자 표현함.
   cat(
     "          ",
     gridName,
     "에서 일어나는 사고건수의 총합 중",
     names(which.max(shipType$stdres[, gridName])),
     "에 일어나는 사고는",
     shipType$observed[, gridName][which.max(shipType$stdres[, gridName])],
     "건이며, ",
     round(shipType$observed[, gridName][which.max(shipType$stdres[, gridName])] / sum(shipType$observed[, gridName]) *100, 2),
     "%를 차지한다.\n"
     )
   
   ### 2-2-3. 사고종류에 대한 시각화
   #### 시각화를 위한 작업
   # shipType 확인
   ## 실제값
   real_C <- shipType$observed[,gridName]
   real_C <- as.data.frame(real_C)
   real_C$'shipType' <- rownames(real_C)
   rownames(real_C) <- c(1:nrow(real_C))
   
   ## 예측값
   expe_C <- round(shipType$expected[,gridName],1)
   expe_C <- as.data.frame(expe_C)
   expe_C$'shipType' <- rownames(expe_C)
   rownames(expe_C) <- c(1:nrow(expe_C))
   
   ## 실제 & 예측 join, 
   last_C <- left_join(real_C,expe_C, by="shipType")
   last_C <- last_C[c(2,1,3)]
   colnames(last_C) <- c("shipType","실제사고수","예측사고수")
   last_C$'실제/예측' <- ifelse(round((last_C$실제사고수) /(last_C$예측사고수),1) %in% c(Inf,NA,NaN),0,round((last_C$실제사고수) /(last_C$예측사고수),1)) 
   last_C <- pivot_longer(last_C, cols =c(`실제사고수`,`예측사고수`) )
   # 시각화 
   # 1) 막대
   p1_C <- ggplot(last_C,aes(x=shipType,y=value,fill=name))+
     geom_bar(stat='identity',position='dodge')+
     geom_text(aes(label=paste0(value,"건")) ,vjust = 1.5,
               position=position_dodge(width=1))+
     scale_fill_manual(values = c("#4292C6","#9ECAE1"))+
     theme_light()+
     theme(panel.border = element_blank(),
           panel.grid.minor.x = element_blank(), # 그래프 보조선 제거(x축)
           axis.title.x = element_blank(), # x축 제목 제거
           legend.position = "bottom",
           legend.title = element_blank())+     # 범례 위치 지정
           labs(y="사고건수")
   # 2) 선
   p2_C <- ggplot(last_C, aes(x = shipType, y = `실제/예측`,group=1)) + geom_line(color = "red") +
     geom_point(color = "red") + geom_text(aes(label = paste0(`실제/예측`, "배"), vjust =
                                              -.3)) +
     #scale_x_discrete(limits=c("봄","여름","가을","겨울"))+
     ggtitle("어선종류별 사고건수(실제,예측) 및 실제값 / 예측값 ")+
     theme_light()+
     theme(panel.border = element_blank(),
           panel.grid.minor.x = element_blank(),
           axis.text.x = element_blank(),
           axis.title.x = element_blank(),
           plot.title = element_text(size=20,color="blue")) +
     scale_y_continuous(limits = c(0,max(last_C$`실제/예측`)+0.2),breaks = seq(1,round(max(last_C$`실제/예측`),1),2))
   # 1) 막대 + 2) 라인
   print(plot_grid(p2_C,p1_C,ncol=1,
                rel_heights = c(.35,.8)))
 
   }
  
  else {
    print("어선종류는 격자별 사고건수와 연관이 없다.")
  }

}


## TEST ##############################################################################

ocenaAccident_DropGeo$OG_ID %>% unique()
# 해양사고 데이터 test
chisq_crushType(ocenaAccident_DropGeo,"GR4_G1N14_E4")

N_ocenaAccident_DropGeo$OG_ID %>% unique()
# 해양사고 이외 데이터 test
chisq_crushType(N_ocenaAccident_DropGeo,"GR3_F2K31_R")

```



# 격자데이터셋에 격자별 카이제곱 결과를 나타내는 열 추가
```{r}
ocean_data_intersect_DropGeo <- ocean_data_intersect %>% st_drop_geometry() 

time <- chisq.test(ocean_data_intersect_DropGeo$해양사고발생시간대,
               ocean_data_intersect_DropGeo$OG_ID)
weather <- chisq.test(ocean_data_intersect_DropGeo$계절,
               ocean_data_intersect_DropGeo$OG_ID)
shipType <- chisq.test(ocean_data_intersect_DropGeo$선박용도_대_ ,
               ocean_data_intersect_DropGeo$OG_ID)
crush <- chisq.test(ocean_data_intersect_DropGeo$해양사고종류_분석용_,
               ocean_data_intersect_DropGeo$OG_ID)

# 사고가 나지 않은 격자에 대한 제외 유무를 정하지 못해 두가지 경우 모두 진행했습니다.
#-------------------------------------------------------------------------------------------------------------------#
# new_grid : 기존 그리드에 대한 데이터(new_Grid)를 다시 정리한 데이터셋
## 1) 사고가 난 그리드는 카이제곱 결과를 출력하고 사고가 안난 그리드는 x로 표시해서 새로운 열로 붙히기

all = {} # 시간에 대한 카이제곱 결과값 저장
all_c={}
all2 = {} # 계절에 대한 카이제곱 결과값 저장
all2_c = {}
all3 = {} # 선박용도에 대한 카이제곱 결과값 저장
all3_c = {}
all4 = {} # 사고 종류에 대한 카이제곱 결과값 저장
all4_c = {}

for(i in 1:nrow(new_grid)){
  if((new_grid$OG_ID[i] %in% grid_yesocean$OG_ID.x) == TRUE){
    Time= names(which.max(time$stdres[, new_grid$OG_ID[i]]))
    Time_몇배 <- round(time$observed[, new_grid$OG_ID[i]][which.max(time$stdres[, new_grid$OG_ID[i]])] / time$expected[, new_grid$OG_ID[i]][which.max(time$stdres[, new_grid$OG_ID[i]])], 1)
    
    Weather= names(which.max(weather$stdres[, new_grid$OG_ID[i]]))
    Weather_몇배 <- round(weather$observed[, new_grid$OG_ID[i]][which.max(weather$stdres[, new_grid$OG_ID[i]])] / weather$expected[, new_grid$OG_ID[i]][which.max(weather$stdres[, new_grid$OG_ID[i]])], 1)
    
    ShipType= names(which.max(shipType$stdres[, new_grid$OG_ID[i]]))
    ShipType_몇배 <- round(shipType$observed[, new_grid$OG_ID[i]][which.max(shipType$stdres[, new_grid$OG_ID[i]])] / shipType$expected[, new_grid$OG_ID[i]][which.max(shipType$stdres[, new_grid$OG_ID[i]])], 1)
    Crush= names(which.max(crush$stdres[, new_grid$OG_ID[i]]))
    Crush_몇배 <- round(crush$observed[, new_grid$OG_ID[i]][which.max(crush$stdres[, new_grid$OG_ID[i]])] / crush$expected[, new_grid$OG_ID[i]][which.max(crush$stdres[, new_grid$OG_ID[i]])], 1)
    
  }
  else{
    Time = "X"
    Time_몇배 = "X"
    Weather = "X"
    Weather_몇배= "X"
    ShipType = "X"
    ShipType_몇배 = "X"
    Crush = "X"
    Crush_몇배="X"
  }
  all <- rbind(all,Time)
  all_c <-  rbind(all_c,Time_몇배)
  
  all2 <- rbind(all2,Weather)
  all2_c <-  rbind(all2_c,Weather_몇배)
  
  all3 <- rbind(all3,ShipType)
  all3_c <-  rbind(all3_c,ShipType_몇배)
  
  all4 <- rbind(all4,Crush)
  all4_c <-  rbind(all4_c,Crush_몇배)
}
new_grid_ChisqResult <- cbind(new_grid,all,all_c,all2,all2_c,all3,all3_c,all4,all4_c)
colnames(new_grid_ChisqResult)[3:10] <- c("Time","Time_몇배", "Season","Season_몇배", "ShipType","ShipType_몇배", "Crush","Crush_몇배")

sum(new_grid_ChisqResult$Time_몇배==0)
sum(new_grid_ChisqResult$Season_몇배==0)
sum(new_grid_ChisqResult$ShipType_몇배==0)
sum(new_grid_ChisqResult$Crush_몇배==0)

# rda파일로 저장
save(new_grid_ChisqResult,file="new_grid_chisqResult.rda")
load("new_grid_chisqResult.rda")

#-------------------------------------------------------------------------------------------------------------------#


```




# 영가설 설정
# H0 : 특정변수(계절, 시간대 등)가 주는 영향이 격자별로 다르지 않다.
# H1 : 특정변수(계절, 시간대 등)가 주는 영향이 격자별로 다르다.

# 어선 비어선으로 나눈 데이터용 함수
```{r}
library(gridExtra)
fishingBoat_DropGeo <- fishingBoat %>% st_drop_geometry() 
N_fishingBoat_DropGeo <- N_fishingBoat %>% st_drop_geometry() 

fishingBoat_DropGeo$해양사고발생시간대 %>% length()
fishingBoat_DropGeo$OG_ID %>% length()
fishingBoat_DropGeo$OG_ID <- as.character(fishingBoat_DropGeo$OG_ID)

## 선박용도별로 나눈 데이터용 함수 (어선(변수명 : fishingBoat_intersect_DropGeo), 비어선)
chisq_ShipType <- function(data,gridName) {
  # 1. 카이제곱대입 - 해양사고발생시간대, 계절, 해양사고종류_분석용_ ##################################################################################################################
  time <-
    chisq.test(data$해양사고발생시간대,
               data$OG_ID)
  wheater <-
    chisq.test(data$계절,
               data$OG_ID)
  crush <-
    chisq.test(data$해양사고종류_분석용_,
               data$OG_ID)
  
  # 2. 텍스트 및 시각화 출력 - 카이제곱 결과에 따라 대입한 그리드에서 많이 일어나는 종류의 사고 파악 ###################################################################################
  
  cat("그리드 번호 입력(''사이에 입력(필수)) : ",gridName , "\n") # 그리드이름 출력
  cat("\n")
  
  
  ## 2-1. 시간대(time) ------------------------------------------------------------------------------------------------------------------------------------------------------------------
   if (time$p.value < 0.05) {
     
     ### 2-1-1. 시간대에 대한 텍스트 출력
     cat("시간대 : ",names(which.max(time$stdres[, gridName])),"\n") # 잔차가 가장 큰 시간대 출력(클수록 사고가 많이 일어나는 시간대임)
     ### 실제값과 예측값의 차이
     cat(
       "        ",
       names(which.max(time$stdres[, gridName])),
       "에 예측보다",
       round(time$observed[, gridName][which.max(time$stdres[, gridName])] / time$expected[, gridName][which.max(time$stdres[, gridName])], 1),
       "배 더 많은 사고가 일어난다. \n"
       )
     ### 해당그리드에서 일어난 사고 중 잔차가 가장 큰 시간대에서 일어난 사고비중 및 건수 - 그리드의 사고 건수 자체가 적을 경우 결과의 정확도가 낮을 수 있기 때문에 그것을 파악하고자 표현함.
     cat(
       "        ",
       gridName,
       "에서 일어나는 사고건수의 총합 중",
       names(which.max(time$stdres[, gridName])),
       "에 일어나는 사고는",
       time$observed[, gridName][which.max(time$stdres[, gridName])],
       "건이며, ",
       round(time$observed[, gridName][which.max(time$stdres[, gridName])] / sum(time$observed[, gridName]) * 100, 2),
       "%를 차지한다.\n")
     
     
     ### 2-1-2. 시간대에 대한 시각화 출력
     #### 시각화를 위한 작업
     # time 확인
     ## 실제값
     real_T <- time$observed[,gridName]
     real_T <- as.data.frame(real_T)
     real_T$'time' <- rownames(real_T)
     rownames(real_T) <- c(1:nrow(real_T))
     ## 예측값
     expe_T <- round(time$expected[,gridName],1)
     expe_T <- as.data.frame(expe_T)
     expe_T$'time' <- rownames(expe_T)
     rownames(expe_T) <- c(1:nrow(expe_T))
     
     ## 실제 & 예측 join, 
     last_T <- left_join(real_T,expe_T, by="time")
     last_T <- last_T[c(2,1,3)]
     colnames(last_T) <- c("time","실제사고수","예측사고수")
     last_T$'실제/예측' <- ifelse(round((last_T$실제사고수) /(last_T$예측사고수),1)%in% c(Inf,NA,NaN),0,round((last_T$실제사고수) /(last_T$예측사고수),1)) 
     last_T <- pivot_longer(last_T, cols =c(`실제사고수`,`예측사고수`) )
     
     #### 시각화
     # 1) 막대
     p1_T <- ggplot(last_T,aes(x=time,y=value,fill=name))+
       geom_bar(stat='identity',position='dodge')+
       geom_text(aes(label=paste0(value,"건")) ,vjust = 1.5,
                 position=position_dodge(width=1))+
       scale_x_discrete(limits=c("0-4시","4-8시","8-12시","12-16시","16-20시","20-24시"))+
       scale_fill_manual(values = c("#4292C6","#9ECAE1"))+
       theme_light()+
       theme(panel.border = element_blank(),
             panel.grid.minor.x = element_blank(), # 그래프 보조선 제거(x축)
             axis.title.x = element_blank(), # x축 제목 제거
             legend.position = "bottom",     # 범례 위치 지정
             legend.title = element_blank())+ # 범례 제목 제거
       labs(y="사고건수")
     # 2) 라인
     p2_T <- ggplot(last_T, aes(x = time, y = `실제/예측`,group=1)) + geom_line(color = "red") +
       geom_point(color = "red") + geom_text(aes(label = paste0(`실제/예측`, "배"), vjust =-.3)) +
       scale_x_discrete(limits=c("0-4시","4-8시","8-12시","12-16시","16-20시","20-24시"))+
       ggtitle("시간대별 사고건수(실제,예측) 및 실제값 / 예측값 ")+
       theme_light()+
       theme(panel.border = element_blank(),
             panel.grid.minor.x = element_blank(),
             axis.text.x = element_blank(),
             axis.title.x = element_blank(),
             plot.title = element_text(size=20,color="blue")) +
       scale_y_continuous(limits = c(0,max(last_T$`실제/예측`)+0.2),
                          breaks = seq(1,round(max(last_T$`실제/예측`),1),2))
     
     # 1) 막대 + 2) 라인
     print(plot_grid(p2_T,p1_T,ncol=1,
                   rel_heights = c(.35,.8)))
   }
  
  else {
    print("시간대는 격자별 사고건수와 연관이 없다.")
  }

  cat("\n")
 cat("------------------------------------------------------------\n")
  
  ## 2-2. 계절(wheater) ----------------------------------------------------------------------------------------------------------------------------------------------------------
 
 if (wheater$p.value < 0.05) {
   
   ### 2-2-1. 계절에 대한 텍스트 출력
   cat("계절 : ",names(which.max(wheater$stdres[, gridName])),"\n") # 잔차가 가장 큰 시간대 출력(클수록 사고가 많이 일어나는 계절임)
   
   ### 실제값과 예측값의 차이
   cat(
     "       ",
     names(which.max(wheater$stdres[, gridName])),
     "에 예측보다",
     round(wheater$observed[, gridName][which.max(wheater$stdres[, gridName])] / wheater$expected[, gridName][which.max(wheater$stdres[, gridName])], 1),
     "배 더 많은 사고가 일어난다. \n"
     )
   ### 해당그리드에서 일어난 사고 중 잔차가 가장 큰 시간대에서 일어난 사고비중 및 건수 - 그리드의 사고 건수 자체가 적을 경우 결과의 정확도가 낮을 수 있기 때문에 그것을 파악하고자 표현함.
   cat(
     "       ",
     gridName,
     "에서 일어나는 사고건수의 총합 중",
     names(which.max(wheater$stdres[, gridName])),
     "에 일어나는 사고는",
     wheater$observed[, gridName][which.max(wheater$stdres[, gridName])],
     "건이며, ",
     round(wheater$observed[, gridName][which.max(wheater$stdres[, gridName])] / sum(wheater$observed[, gridName]) *100, 2),
     "%를 차지한다.\n"
   )
   
   ### 2-2-2. 계절에 대한 시각화
   #### 시각화를 위한 작업
   # wheater 확인
   ## 실제값
   real_W <- wheater$observed[,gridName]
   real_W <- as.data.frame(real_W)
   real_W$'wheater' <- rownames(real_W)
   rownames(real_W) <- c(1:nrow(real_W))
   
   ## 예측값
   expe_W <- round(wheater$expected[,gridName],1)
   expe_W <- as.data.frame(expe_W)
   expe_W$'wheater' <- rownames(expe_W)
   rownames(expe_W) <- c(1:nrow(expe_W))
   
   # 실제 & 예측 join, 
   last_W <- left_join(real_W,expe_W, by="wheater")
   last_W <- last_W[c(2,1,3)]
   colnames(last_W) <- c("wheater","실제사고수","예측사고수")
   last_W$'실제/예측' <- ifelse(round((last_W$실제사고수) /(last_W$예측사고수),1)%in% c(Inf,NA,NaN),0,round((last_W$실제사고수) /(last_W$예측사고수),1)) 
   last_W <- pivot_longer(last_W, cols =c(`실제사고수`,`예측사고수`) )
   
   # 시각화 
   # 1) 막대
   p1_W <- ggplot(last_W,aes(x=wheater,y=value,fill=name))+
     geom_bar(stat='identity',position='dodge')+
     geom_text(aes(label=paste0(value,"건")) ,vjust = 1.5,
               position=position_dodge(width=1))+
     scale_x_discrete(limits=c("봄","여름","가을","겨울"))+
     scale_fill_manual(values = c("#4292C6","#9ECAE1"))+
     theme_light()+
     theme(panel.border = element_blank(),
           panel.grid.minor.x = element_blank(), # 그래프 보조선 제거(x축)
           axis.title.x = element_blank(), # x축 제목 제거
           legend.position = "bottom",     # 범례 위치 지정
           legend.title = element_blank())+ # 범례 제목 제목
     labs(y="사고건수")
   
   # 2) 선
   p2_W <- ggplot(last_W, aes(x = wheater, y = `실제/예측`,group=1)) + geom_line(color = "red") +
     geom_point(color = "red") + geom_text(aes(label = paste0(`실제/예측`, "배"), vjust =
                                              -.3)) +
     scale_x_discrete(limits=c("봄","여름","가을","겨울"))+
     ggtitle("계절별 사고건수(실제,예측) 및 실제값 / 예측값 ")+
     theme_light()+
     theme(panel.border = element_blank(),
           panel.grid.minor.x = element_blank(),
           axis.text.x = element_blank(),
           axis.title.x = element_blank(),
           plot.title = element_text(size=20,color="blue")) +
     scale_y_continuous(limits = c(0,max(last_W$`실제/예측`)+0.2)
                        ,breaks = seq(1,round(max(last_W$`실제/예측`),1),2))
   # 1) 막대 + 2) 라인
   print(plot_grid(p2_W,p1_W,ncol=1,
                   rel_heights = c(.35,.8)))
   }
  
  else {
    print("계절은 격자별 사고건수와 연관이 없다.")
  }
 
  cat("\n")
  cat("------------------------------------------------------------\n")
  
  
  ## 2-3. 해양사고종류(crush) -------------------------------------------------------------------------------------------------------------------------------------------
 
 if (crush$p.value < 0.05) {
   
   ### 2-3-1. 사고종류에 대한 텍스트 출력
   
   cat("해양사고종류 : ",names(which.max(crush$stdres[, gridName])),ifelse(names(which.max(crush$stdres[, gridName])) %in% c("충돌", "접촉", "좌초", "전복","침몰"),"(해양교통사고 O)","(해양교통사고 X)"),"\n") # 잔차가 가장 큰 시간대 출력(클수록 사고가 많이 일어나는 계절임) 
   ### 실제값과 예측값의 차이
   cat(
     "             ",
     names(which.max(crush$stdres[, gridName])),
     "에 예측보다",
     round(crush$observed[, gridName][which.max(crush$stdres[, gridName])] / crush$expected[, gridName][which.max(crush$stdres[, gridName])], 1),
     "배 더 많은 사고가 일어난다. \n"
     )
   ### 해당그리드에서 일어난 사고 중 잔차가 가장 큰 시간대에서 일어난 사고비중 및 건수 - 그리드의 사고 건수 자체가 적을 경우 결과의 정확도가 낮을 수 있기 때문에 그것을 파악하고자 표현함.
   cat(
     "             ",
     gridName,
     "에서 일어나는 사고건수의 총합 중",
     names(which.max(crush$stdres[, gridName])),
     "에 일어나는 사고는",
     crush$observed[, gridName][which.max(crush$stdres[, gridName])],
     "건이며, ",
     round(crush$observed[, gridName][which.max(crush$stdres[, gridName])] / sum(crush$observed[, gridName]) *100, 2),
     "%를 차지한다.\n"
     )
   
   ### 2-2-3. 사고종류에 대한 시각화
   #### 시각화를 위한 작업
   # crush 확인
   ## 실제값
   real_C <- crush$observed[,gridName]
   real_C <- as.data.frame(real_C)
   real_C$'crush' <- rownames(real_C)
   rownames(real_C) <- c(1:nrow(real_C))
   
   ## 예측값
   expe_C <- round(crush$expected[,gridName],1)
   expe_C <- as.data.frame(expe_C)
   expe_C$'crush' <- rownames(expe_C)
   rownames(expe_C) <- c(1:nrow(expe_C))
   
   ## 실제 & 예측 join, 
   last_C <- left_join(real_C,expe_C, by="crush")
   last_C <- last_C[c(2,1,3)]
   colnames(last_C) <- c("crush","실제사고수","예측사고수")
   last_C$'실제/예측' <- ifelse(round((last_C$실제사고수) /(last_C$예측사고수),1) %in% c(Inf,NA,NaN),0,round((last_C$실제사고수) /(last_C$예측사고수),1)) 
   last_C <- pivot_longer(last_C, cols =c(`실제사고수`,`예측사고수`) )
   # 시각화 
   # 1) 막대
   p1_C <- ggplot(last_C,aes(x=crush,y=value,fill=name))+
     geom_bar(stat='identity',position='dodge')+
     geom_text(aes(label=paste0(value,"건")) ,vjust = 1.5,
               position=position_dodge(width=1))+
     scale_fill_manual(values = c("#4292C6","#9ECAE1"))+
     theme_light()+
     theme(legend.position="bottom",
           legend.title = element_blank(),
           panel.border = element_blank(),
           panel.grid.minor.x = element_blank(), # 그래프 보조선 제거(x축)
           axis.title.x = element_blank())+     # 범례 위치 지정
           labs(y="사고건수")
   # 2) 선
   p2_C <- ggplot(last_C, aes(x = crush, y = `실제/예측`,group=1)) + geom_line(color = "red") +
     geom_point(color = "red") + geom_text(aes(label = paste0(`실제/예측`, "배"), vjust =
                                              -.3)) +
     #scale_x_discrete(limits=c("봄","여름","가을","겨울"))+
     ggtitle("사고종류별 사고건수(실제,예측) 및 실제값 / 예측값 ")+
     theme_light()+
     theme(panel.border = element_blank(),
           panel.grid.minor.x = element_blank(),
           axis.text.x = element_blank(),
           axis.title.x = element_blank(),
           plot.title = element_text(size=20,color="blue")) +
     scale_y_continuous(limits = c(0,max(last_C$`실제/예측`)+0.2),breaks = seq(1,round(max(last_C$`실제/예측`),1),2))+
     coord_fixed(ratio=.5)
   # 1) 막대 + 2) 라인
   p2_CC <- ggplotly(p2_C)
   p1_CC <- ggplotly(p1_C)
   a <- subplot(p2_CC,p1_CC,nrows=2,heights = c(.35,.65))
   print(a)
   }
  
  else {
    print("사고종류는 격자별 사고건수와 연관이 없다.")
  }

}
## TEST ##############################################################
# 어선데이터 test
fishingBoat_DropGeo$OG_ID %>% unique()
a <- chisq_ShipType(fishingBoat_DropGeo,"GR4_G3E43_I4")
a

# 비어선데이터 test
N_fishingBoat_DropGeo$OG_ID %>% unique()
chisq_ShipType(N_fishingBoat_DropGeo,"GR3_F4L12_Y")


```



